/*
 *
 */

	.text
	.align 2
	.global _print_string
	  
/* _put_string responsible for decoding the ascii string and selecting
 *	correct font. By default string will be	sent to stdout (screen).
 *
 *	arguments:-
 *			r0	destination output [1 - stdout]
 *			r1	string start addr
 *			r2	number of char
 *
 *	
*/
_print_string:
	teq r2, $0x00				@ Test for at least 1 char
	moveq r0, $0x01				@ return error
	bxeq lr

	stmfd sp!, {r4-r11, lr}
	ldr r12, =SystemFont
	ldr r11, [r12]
	bx r11
	nop
	nop

_u_vga16:
	mov r4, r2				@ copy n.o chars in string
	mov r5, r1				@ copy string addr
	ldr r11, =Uvga16
	add r11, r11, $0x30			@ offset to font data
	ldr r10, =CursorLoc
	ldrd r6, r7, [r10]

_X1:
	push {r4}
	ldrb r3, [r5], $0x01
	sub r3, r3, $0x20			@ sync ascii no to glyph pos

	add r4, r11, r3, lsl #4			@ glyph addr
	mov r9, $0x04				@ y counter
_X2:
	ldr r10, [r4], $0x04
	rev r10, r10
	mov r8, $0x08				@ x counter

	/* Optimsed for speed (12 less branches, 12 less mem calls per loop
		 = aprox 232 cycles */
_XL0:
	movs r10, r10, lsl #1			@ tst if bit falls off	
	movcs r0, r6
	movcs r1, r7
	blcs _set_pixel
	add r6, r6, $0x01
	subs r8, r8, $0x01
	bne _XL0
	sub r6, r6, $0x08
	add r7, r7, $0x01
	mov r8, $0x08				@ x counter
_XL1:
	movs r10, r10, lsl #1			@ tst if bit falls off	
	movcs r0, r6
	movcs r1, r7
	blcs _set_pixel
	add r6, r6, $0x01
	subs r8, r8, $0x01
	bne _XL1
	sub r6, r6, $0x08
	add r7, r7, $0x01
	mov r8, $0x08				@ x counter
_XL2:
	movs r10, r10, lsl #1			@ tst if bit falls off	
	movcs r0, r6
	movcs r1, r7
	blcs _set_pixel
	add r6, r6, $0x01
	subs r8, r8, $0x01
	bne _XL2
	sub r6, r6, $0x08
	add r7, r7, $0x01
	mov r8, $0x08				@ x counter
_XL3:
	movs r10, r10, lsl #1			@ tst if bit falls off	
	movcs r0, r6
	movcs r1, r7
	blcs _set_pixel
	add r6, r6, $0x01
	subs r8, r8, $0x01
	bne _XL3
	add r7, r7, $0x01

_YL:
	subs r9, r9, $0x01			@ font height counter
	subeq r7, r7, $0x10
	subne r6, r6, $0x08			@ reset x	
	bne _X2					@ next row

_X3:

	pop {r4}
	subs r4, r4, $0x01			@ next char or exit
	bne _X1
	ldr r11, =CursorPos
	str r12, [r11]
	ldr r10, =CursorLoc
	strd r6, r7, [r10]			@ update CursorLoc

	ldmfd sp!, {r4-r11, pc}			@ exit


	/* large fonts rarly used/
_16_24:
	movne r2, r3, lsl #5
	addne r0, r2, r3, lsl #4		@ mul by 0x30 to get glyph
	add r11, r11, r0			@ glyph addr 

_L4:	
	ldrh r9, [r11], $0x02			@ ldr row
	and r0, r9, $0xff			@ swapping lower bytes round
	mov r9, r9, lsr #8			@  due to endianess
	orr r9, r9, r0, lsl #8
	mov r8, r5				@ cp width for counter
	mov r10, r6				@ cp x position
	mov r9, r9, lsl #16

_xloop:
	movs r9, r9, lsl #1			@ tst if bit falls off	
	movcs r0, r10
	movcs r1, r7
	blcs _set_pixel
	add r10, r10, $0x01
	subs r8, r8, $0x01
	bne _xloop

_yloop:
	subs r4, r4, $0x01			@ font height counter
	addne r7, r7, $0x01			@ incr y to next row
	
	bne _L4					@ next row

_L5:
	pop {r2, r4-r12}
	add r6, r6, r5
	strd r6, r7, [r10]			@ update CursorLoc

	subs r2, r2, $0x01			@ next char or exit
	bne _L1

	cmp r8, $0x00
	bne _B0 
	ldmfd sp!, {r4-r11, pc}			@ exit

	/* 1st 0x1f charactor have no glyphs but do have funtions. Bellow 
	 * only CR, Tab, Delete are being delt with for time being
	 */

_special_char:
	ldmfd sp!, {r4-r11, pc}			@ exit
/*
	add r6, r6, $0x20				@ easier using genuine
							@  ascii code
cr:
	teq r6, $0x0d
	moveq r8, $0x10
	addeq r9, $0x18
	ldreqd r8, r9, [r3]				@ update CursorLoc
htab:
	teq r6, $0x09
	addeq r8, $0x120		
	ldreqd r8, r9, [r3]				@ update CursorLoc
delete: @TODO
	b _glyph_addr
*/


	.data
	.align 2
	.global SystemFont
SystemFont:
	.word	_u_vga16
